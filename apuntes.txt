***Clase 2 Zen de python***

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.
- Special cases aren't special enough to break the rules.
- Although practicality beats purity.
- Errors should never pass silently.
- Unless explicitly silenced.
- In the face of ambiguity, refuse the temptation to guess.
- There should be one-- and preferably only one --obvious way to do it.
- Although that way may not be obvious at first unless you're Dutch.
- Now is better than never.
- Although never is often better than *right* now.
- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.
- Namespaces are one honking great idea -- let's do more of those!

Traducci√≥n

- Bello es mejor que feo:
    - Pyhton es est√©ticamente superior a cualquier otro lenguaje de programaci√≥n. Al momento de escribir c√≥digo, es mejor que sea de manera limpia y est√©tica.
- Expl√≠cito es mejor que impl√≠cito:
    - Hacer m√°s f√°cil que las otras personas entiendan el c√≥digo.
- Simple es mejor que complejo:
    - Es mejor tener una implementaci√≥n simple, que ocupe pocas lineas de c√≥digo y sea entendible, a que sea una larga y complicada.
- Complejo es mejor que complicado:
    - Si tenemos que extendernos en la implementaci√≥n y hacerla m√°s compleja para que el c√≥digo si se entienda, esto es mejor que hacerlo simple y mal.
- Plano es mejor que anidado:
    - El anidamiento es cuando tenemos un bloque de c√≥digo dentro de otro bloque de c√≥digo (dependiendo de este). Esto se nota en Python por la identaci√≥n, nos quedar√≠an estos bloques muy corridos a la derecha.
    - Es mejor evitar el anidamiento, y hacer las cosas de manera plana.
- Espaciado es mejor que denso:
    - Por la identaci√≥n de Python (sus sangr√≠as), este principio se nos hace imposible de esquivar. El c√≥digo inevitablemente es espaciado.
- La legibilidad es importante:
    - Es importante que otros programadores puedan entender lo que estamos escribiendo. Esto hace m√°s f√°ciles las cosas cuando trabajemos con otros en los proyectos.
- Los casos especiales no son lo suficientemente especiales cpmo para romper las reglas (sin embargo, la practicidad le gana a la pureza):
    - Siempre que podamos respetar estas reglas que nos plantea Python, es mejor as√≠. Sin embargo, si por el hecho de hacer un c√≥digo muy puro o muy ‚ÄòPythonista‚Äô, este pierde legibilidad, es mejor ser m√°s pr√°cticos y romper o saltearnos algunas de estas reglas para que el c√≥digo sea m√°s eficiente. Por lo tanto, llegado el momento debermos decidir si es mejor hacer las cosas de manera pura o pr√°ctica.
- Los errores nunca deber√≠an pasar silenciosamente (a menos que se silencien expl√≠citamente):
    - Manejar los erroes es fundamental. Cada error nos dice algo y hay que prestarle atenci√≥n. A menos que seas capaz de silenciar un error expl√≠citamente, aunque para esto hay que tener criterio.
- Frente a la ambiguedad, evitar la tentaci√≥n de adivinar:
    - Nuestro c√≥digo deber√≠a solamente tener una interpretaci√≥n. Si en un contexto significa algo, y en otro otra cosa, es mejor que lo revisemos y busquemos una soluci√≥n.
- Deber√≠a haber una, y preferiblemente sola, una manera obvia de hacerlo. (A pesar de que esa manera no sea obvia a menos que seas holand√©s):
    - Esto hace referencia al creador de Python ''Guido van Rossum", que de manera muy inteligente encontrar las soluciones precisas a los problemas, y deber√≠amos imitarlo.
- Ahora es mejor que nunca:
    - Es mejor desarrollar nuestra soluci√≥n cu√°nto antes, no dejarlo para ma√±ana o para mas adelante.
- A pesar de que nunca es muchas veces mejor que ahora mismo:
    - Si por hacer las cosas ya y tenemos poco tiempo, si es mejor dejarlo para despu√©s y no hacerlo apurado y mal.
- Si la implementaci√≥n es d√≠ficil de explicar, es una mala idea, y si es f√°cil de explicar, es una buena idea:
    - Si somos capaces de explicar nuestra implementaci√≥n a otros desarrolladores paso a paso, es una buena idea. En cambio si no podemos hacerlo, significa que ni nosotros entendemos la implementaci√≥n y deber√≠amos repensar nuestra forma de encarar la soluci√≥n.
- **Los espacios de nombres son una gran idea, ¬°Tengamos m√°s de esos! (namespaces):
    - Es el nombre que se ha indicado luego de la palabra import, es decir la ruta (namespace) del m√≥dulo. (Lo veremos a profundidad m√°s adelante).

***Clase 3 ¬øQu√© es la documentaci√≥n?***

En esta encontramos todo con respecto a la funcionalidad del lenguaje, errores, sint√°xis, referencias del lenguajes, tutoriales
ah√≠ encontramos los PEP: son los documentos que conforman a toda la gu√≠a de estilos del lenguaje, es una gu√≠a de como se debe escribir el lenguaje python, el pep8 es la guia de estilos de python
en esta podemos ver las buenas pr√°cticas que debemos tener para escribir python

https://peps.python.org/pep-0008/

***Clase 4 ¬øQu√© es un entorno virtual?***

M√≥dulo: B√°sicamente es c√≥digo escrito por otra persona que nos sirve para solucionar un problema de manera r√°pida
por ejemplo tenemos el m√≥dulo Random

Es ese python aislado para un solo proyecto que tiene sus propios m√≥dulos y funcionar √∫nicamente ah√≠

Aprend√≠ sobre los entornos virtuales gracias al Curso de Creaci√≥n Lenguajes de Programaci√≥n: Int√©rpretes, la idea es sencilla, de hecho el concepto es similar al de los contenedores de Docker, como profesional empezar√°s a requerir de trabajar diversos proyectos que trabajen con diferentes versiones, ya sea del lenguaje o de alg√∫n m√≥dulo.
Ser√≠a una cat√°strofe tener que instalar y actualizar m√≥dulos para cada proyecto cuidando que ninguno se rompa, porque f√°cilmente podr√≠as actualizar un m√≥dulo que, para un proyecto funcione, pero para otro deje de funcionar, es por eso que se crea el concepto de entornos virtuales.
Este concepto lo tienen muchos lenguajes, y lo genial es que soluciona muy bien el problema de la compatibilidad entre proyectos, porque cada entorno virtual es independiente y funciona con las versiones que se les hayan instalado ah√≠ mismo üòÑ.

Recomendado de la Clase:

https://platzi.com/cursos/interpretes-software/

***Clase 5 El primer paso profesional: creaci√≥n de un entorno virtual***

para crear un ambiente en windows con cmder me funcion√≥ as√≠:
- python -m venv venv
- python -m venv venv2

- -m -> significa que vamos a modificar el funcionamiento normal por otra cosa, y en python -m significa modulo, es decir, vamos a llamar a un m√≥dulo interno del lenguaje
- venv -> significa que estamos llamando al m√≥dulo venv que hace referencia al entorno virtual, lo que quiere decir es que le estamos diciendo a la consola que nos cree un virtual environment
- venv2 -> es el nombre que le vamos a colocar al entorno virtual

y ya con eso se nos crea el entorno virtual para trabajar 
- ahora para entrar al entorno virtual y trabajar, es decir, activarlo es as√≠:

- para activar el entorno virtual en Mac o linux:
    - source venv/bin/activate
        donde venv recordar que es el nombre del entorno virtual
- para activar el entorno virtual en windows con cmder
    .\venv\Scripts\activate
- para activar el entorno virtual en windows con git bash
    source venv2/Scripts/activate

usualmente en el mundo de la programaci√≥n se suele llamar al entorno virtual que se crea como venv al igual que el m√≥dulo, pero en este ejemplo para evitar confusiones lo cre√© como venv2

***Clase 6 Instalaci√≥n de dependencias con pip***

- PIP: Package Installer for Python
hay m√≥dulos que est√°n dentro de python pero hay otros que no est√°n instalados, por ende, para obtenerlos usamos pip
este m√≥dulo viene dentro de python para instalar otros m√≥dulos
por ejemplo:
    - Requests
    - BeautifulSoup4
    - Pandas
    - Numpy
    - Pytest

cuando ingresamos al entorno virtual e instalamos m√≥dulos o dependencias, estas quedan instaladas solo en ese entorno virtual
- pip freeze: con este comando podemos ver qu√© m√≥dulos tenemos instalados ya sea en nuestro entorno virtual como por fuera
y para instalar un m√≥dulo es as√≠, como ejemplo:

- pip install pandas
- pip install django

IMPORTANTE:

si por ejemplo yo estoy desarrollando una app y quiero que un compa√±ero u otra persona en su entorno instale exactamente los mismos requerimientos que yo tengo
o los mismos m√≥dulos, lo hago de la siguiente manera:

- pip freeze > requirements.txt
y ya con eso, tenemos los programas que tengo en mi local listos para pasarselos a otra persona, y ahora para que esa persona los pueda instalar exactos a los mios
debo ejecutar el siguiente comando:
- pip install -r requirements.txt

https://pypi.org/project/pipenv/
Quiz entorno virtual

***Clase 7 Listas y diccionarios anidados***

cuando creo el archivo .gitignore y no quiero subir un entorno virtual lo coloco en el .gitignore as√≠:
- venv/
o as√≠:
*venv

***Clase 8 List comprehensions***

ejemplo de una list comprehensions

    squares = [i**2 for i in range(1,11) if i % 3!=0]
    print(squares)
voy a leer la list comprehensions anterior:
    - para cada i en el rango que va de 1 hasta 11 voy a guardar esa i elevada al cuadrado solamente si la i modulo 3 es distinta de 0 
        - en otras palabras: para cada i de los n√∫meros del 1 a 11 voy a guardar esa i al cuadrado solamente si no es divisible por 3
explicaci√≥n por partes de la list comprehensions
[element for element in iterable if condition]

- element
    - Representa a cada uno de los elementos a poner en una nueva lista
- for element in iterable
    - Ciclo a partir del cual se extraer√°n elementos de otra lista o cualquier iterable
- if condition
    - Condici√≥n opcional para filtrar los elementos del ciclo
y se lee as√≠:
para cada elemento en el iterable voy a guardar ese elemento solo si se cumple la condici√≥n

***Clase 9 Dictionary comprehensions***

{key:value for value in iterable if condition}

- key:value -> Representa a cada una de las llaves y valores a poner en el nuevo diccionario
- for value in iterable ->
- if condition -> condici√≥n opcional para filtrar los elementos del ciclo
se lee as√≠:
para cada elemento en el iterable voy a colocar una llave y un valor solamente si se cumple la condici√≥n
Quiz alternativa a los ciclos: comprehensions

***Clase 10 Funciones an√≥nimas: lambda***

las funciones an√≥nimas valga la redundancia es una funci√≥n sin nombre, es decir, que no tienen identificador 
y su estructura es as√≠:

lambda argumentos: expresi√≥n

las funciones lambda puede tener los argumentos que nosotros queramos o necesitemos pero una sola l√≠nea de c√≥digo

se conforma de un argumento que es el parametro que recibe la funci√≥n para trabajar acompa√±ado de la palabra clave lambda, luego tenemos una expresi√≥n que es una l√≠nea de c√≥digo
y tenemos una variable que es un identificador, tener en cuenta que ese identificador no es de la funci√≥n, es de una variable que va contener un objeto de tipo funci√≥n que retorna 
todo, recordar que la funci√≥n lambda no tiene nombre, pero el nombre que tiene esa funci√≥n con el que la vamos a llamar va ser el nombre de la variable 

- lo bueno de las funciones lambda es que no se necesita poner return
ejemplo:

palindrome = lambda string:string ==sting[::-1]
print(palindrome('oso'))

y en una funci√≥n normal, ser√≠a as√≠:

def palindrome(string):
    return string == string[::-1]
print(palindrome('ana'))

lo que es lo mismo y debe retornar True o False, en lugar de usar def uso lambda en lugar de pasar los parametros en parentesis, en lambda los coloco sin parentesis
el identificador se acostumbra a ponerlo como el nombre de la variable en lugar del nombre de la funci√≥n y en lambda no coloco la palabra clave return, simplemente la omito

***Clase 11 High order functions: filter, map y reduce***

Funciones de orden superior:
    - Es una funci√≥n que recibe otra funci√≥n como par√°metro

    - filter: 
        para su uso como ejemplo, tenemos una lista con n√∫meros:
        my_list = [1,4,5,6,9,13,19,21]
        y quiero tener una lista de esos n√∫meros, pero √∫nicamente los que son impares
        [1,5,9,13,19,21]
        y lo usamos solo con list comprehensions
        my_list = [1,4,5,6,9,13,19,21]
        odd = [i for i in my_list if i %2 !=0]
        print(odd)
        
        ahora lo hacemos con list comprehensions y lambda, y la explicaci√≥n es as√≠:
        esta lambda lo que hace es, recibe como par√°metro una x y retorna el resultado de una expresi√≥n x%2 != 0
        en otras palabras, recibe un n√∫mero y retorna True o False si ese n√∫mero es par o impar, adem√°s tenemos una lista que es el segundo
        par√°metro de la funci√≥n filter, la funci√≥n filter es una funci√≥n de orden superior que recibe dos par√°metros una funci√≥n que en este caso
        es una funci√≥n an√≥nima una lambda function y un iterable que en este caso es una lista, ahora est√° funci√≥n filter no nos va a devolver
        la lista que nosotros queremos porque retorna un iterador, entonces para que sea una lista lo que hacemos es colocar el m√©todo lista por encima 
        de la funci√≥n filter as√≠: list(filter)) para que mi resultado quede dentro de una lista

        my_list = [1,4,5,6,9,13,19,21]
        odd = list(filter(lambda x: x%2 != 0, my_list))
        print(odd)
        
    - map: 
        funciona exactamente igual a filter, ejemplo:
        my_list = [1,4,5,6,9,13,19,21]
        odd = list(map(lambda x: x**2, my_list))
        print(odd)
    - reduce: 

***Clase 12 Proyecto: filtrando datos***
Quiz conceptos avanzados de funciones

***Clase 13 Los errores en el c√≥digo***

***Clase 14 Debugging***

***Clase 15 Manejo de excepciones***

***Clase 16 Poniendo a prueba el manejo de excepciones***

***Clase 17 Assert statements***
Quiz manejo de errores

***Clase 18 ¬øC√≥mo trabajar con archivos?***

***Clase 19 Trabajando con archivos de texto en Python***
Quiz manejo de archivos

***Clase 20 Reto final: Juego del Ahorcado o Hangman Game***

***Clase 21 Contin√∫a tu camino profesional con Python***
