***Clase 2 Zen de python***

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.
- Special cases aren't special enough to break the rules.
- Although practicality beats purity.
- Errors should never pass silently.
- Unless explicitly silenced.
- In the face of ambiguity, refuse the temptation to guess.
- There should be one-- and preferably only one --obvious way to do it.
- Although that way may not be obvious at first unless you're Dutch.
- Now is better than never.
- Although never is often better than *right* now.
- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.
- Namespaces are one honking great idea -- let's do more of those!

TraducciÃ³n

- Bello es mejor que feo:
    - Pyhton es estÃ©ticamente superior a cualquier otro lenguaje de programaciÃ³n. Al momento de escribir cÃ³digo, es mejor que sea de manera limpia y estÃ©tica.
- ExplÃ­cito es mejor que implÃ­cito:
    - Hacer mÃ¡s fÃ¡cil que las otras personas entiendan el cÃ³digo.
- Simple es mejor que complejo:
    - Es mejor tener una implementaciÃ³n simple, que ocupe pocas lineas de cÃ³digo y sea entendible, a que sea una larga y complicada.
- Complejo es mejor que complicado:
    - Si tenemos que extendernos en la implementaciÃ³n y hacerla mÃ¡s compleja para que el cÃ³digo si se entienda, esto es mejor que hacerlo simple y mal.
- Plano es mejor que anidado:
    - El anidamiento es cuando tenemos un bloque de cÃ³digo dentro de otro bloque de cÃ³digo (dependiendo de este). Esto se nota en Python por la identaciÃ³n, nos quedarÃ­an estos bloques muy corridos a la derecha.
    - Es mejor evitar el anidamiento, y hacer las cosas de manera plana.
- Espaciado es mejor que denso:
    - Por la identaciÃ³n de Python (sus sangrÃ­as), este principio se nos hace imposible de esquivar. El cÃ³digo inevitablemente es espaciado.
- La legibilidad es importante:
    - Es importante que otros programadores puedan entender lo que estamos escribiendo. Esto hace mÃ¡s fÃ¡ciles las cosas cuando trabajemos con otros en los proyectos.
- Los casos especiales no son lo suficientemente especiales cpmo para romper las reglas (sin embargo, la practicidad le gana a la pureza):
    - Siempre que podamos respetar estas reglas que nos plantea Python, es mejor asÃ­. Sin embargo, si por el hecho de hacer un cÃ³digo muy puro o muy â€˜Pythonistaâ€™, este pierde legibilidad, es mejor ser mÃ¡s prÃ¡cticos y romper o saltearnos algunas de estas reglas para que el cÃ³digo sea mÃ¡s eficiente. Por lo tanto, llegado el momento debermos decidir si es mejor hacer las cosas de manera pura o prÃ¡ctica.
- Los errores nunca deberÃ­an pasar silenciosamente (a menos que se silencien explÃ­citamente):
    - Manejar los erroes es fundamental. Cada error nos dice algo y hay que prestarle atenciÃ³n. A menos que seas capaz de silenciar un error explÃ­citamente, aunque para esto hay que tener criterio.
- Frente a la ambiguedad, evitar la tentaciÃ³n de adivinar:
    - Nuestro cÃ³digo deberÃ­a solamente tener una interpretaciÃ³n. Si en un contexto significa algo, y en otro otra cosa, es mejor que lo revisemos y busquemos una soluciÃ³n.
- DeberÃ­a haber una, y preferiblemente sola, una manera obvia de hacerlo. (A pesar de que esa manera no sea obvia a menos que seas holandÃ©s):
    - Esto hace referencia al creador de Python ''Guido van Rossum", que de manera muy inteligente encontrar las soluciones precisas a los problemas, y deberÃ­amos imitarlo.
- Ahora es mejor que nunca:
    - Es mejor desarrollar nuestra soluciÃ³n cuÃ¡nto antes, no dejarlo para maÃ±ana o para mas adelante.
- A pesar de que nunca es muchas veces mejor que ahora mismo:
    - Si por hacer las cosas ya y tenemos poco tiempo, si es mejor dejarlo para despuÃ©s y no hacerlo apurado y mal.
- Si la implementaciÃ³n es dÃ­ficil de explicar, es una mala idea, y si es fÃ¡cil de explicar, es una buena idea:
    - Si somos capaces de explicar nuestra implementaciÃ³n a otros desarrolladores paso a paso, es una buena idea. En cambio si no podemos hacerlo, significa que ni nosotros entendemos la implementaciÃ³n y deberÃ­amos repensar nuestra forma de encarar la soluciÃ³n.
- **Los espacios de nombres son una gran idea, Â¡Tengamos mÃ¡s de esos! (namespaces):
    - Es el nombre que se ha indicado luego de la palabra import, es decir la ruta (namespace) del mÃ³dulo. (Lo veremos a profundidad mÃ¡s adelante).

***Clase 3 Â¿QuÃ© es la documentaciÃ³n?***

En esta encontramos todo con respecto a la funcionalidad del lenguaje, errores, sintÃ¡xis, referencias del lenguajes, tutoriales
ahÃ­ encontramos los PEP: son los documentos que conforman a toda la guÃ­a de estilos del lenguaje, es una guÃ­a de como se debe escribir el lenguaje python, el pep8 es la guia de estilos de python
en esta podemos ver las buenas prÃ¡cticas que debemos tener para escribir python

https://peps.python.org/pep-0008/

***Clase 4 Â¿QuÃ© es un entorno virtual?***

MÃ³dulo: BÃ¡sicamente es cÃ³digo escrito por otra persona que nos sirve para solucionar un problema de manera rÃ¡pida
por ejemplo tenemos el mÃ³dulo Random

Es ese python aislado para un solo proyecto que tiene sus propios mÃ³dulos y funcionar Ãºnicamente ahÃ­

AprendÃ­ sobre los entornos virtuales gracias al Curso de CreaciÃ³n Lenguajes de ProgramaciÃ³n: IntÃ©rpretes, la idea es sencilla, de hecho el concepto es similar al de los contenedores de Docker, como profesional empezarÃ¡s a requerir de trabajar diversos proyectos que trabajen con diferentes versiones, ya sea del lenguaje o de algÃºn mÃ³dulo.
SerÃ­a una catÃ¡strofe tener que instalar y actualizar mÃ³dulos para cada proyecto cuidando que ninguno se rompa, porque fÃ¡cilmente podrÃ­as actualizar un mÃ³dulo que, para un proyecto funcione, pero para otro deje de funcionar, es por eso que se crea el concepto de entornos virtuales.
Este concepto lo tienen muchos lenguajes, y lo genial es que soluciona muy bien el problema de la compatibilidad entre proyectos, porque cada entorno virtual es independiente y funciona con las versiones que se les hayan instalado ahÃ­ mismo ðŸ˜„.

Recomendado de la Clase:

https://platzi.com/cursos/interpretes-software/

***Clase 5 El primer paso profesional: creaciÃ³n de un entorno virtual***

para crear un ambiente en windows con cmder me funcionÃ³ asÃ­:
- python -m venv venv
- python -m venv venv2

- -m -> significa que vamos a modificar el funcionamiento normal por otra cosa, y en python -m significa modulo, es decir, vamos a llamar a un mÃ³dulo interno del lenguaje
- venv -> significa que estamos llamando al mÃ³dulo venv que hace referencia al entorno virtual, lo que quiere decir es que le estamos diciendo a la consola que nos cree un virtual environment
- venv2 -> es el nombre que le vamos a colocar al entorno virtual

y ya con eso se nos crea el entorno virtual para trabajar 
- ahora para entrar al entorno virtual y trabajar, es decir, activarlo es asÃ­:

- para activar el entorno virtual en Mac o linux:
    - source venv/bin/activate
        donde venv recordar que es el nombre del entorno virtual
- para activar el entorno virtual en windows con cmder
    .\venv\Scripts\activate
- para activar el entorno virtual en windows con git bash
    source venv2/Scripts/activate

usualmente en el mundo de la programaciÃ³n se suele llamar al entorno virtual que se crea como venv al igual que el mÃ³dulo, pero en este ejemplo para evitar confusiones lo creÃ© como venv2

***Clase 6 InstalaciÃ³n de dependencias con pip***

- PIP: Package Installer for Python
hay mÃ³dulos que estÃ¡n dentro de python pero hay otros que no estÃ¡n instalados, por ende, para obtenerlos usamos pip
este mÃ³dulo viene dentro de python para instalar otros mÃ³dulos
por ejemplo:
    - Requests
    - BeautifulSoup4
    - Pandas
    - Numpy
    - Pytest

cuando ingresamos al entorno virtual e instalamos mÃ³dulos o dependencias, estas quedan instaladas solo en ese entorno virtual
- pip freeze: con este comando podemos ver quÃ© mÃ³dulos tenemos instalados ya sea en nuestro entorno virtual como por fuera
y para instalar un mÃ³dulo es asÃ­, como ejemplo:

- pip install pandas
- pip install django

IMPORTANTE:

si por ejemplo yo estoy desarrollando una app y quiero que un compaÃ±ero u otra persona en su entorno instale exactamente los mismos requerimientos que yo tengo
o los mismos mÃ³dulos, lo hago de la siguiente manera:

- pip freeze > requirements.txt
y ya con eso, tenemos los programas que tengo en mi local listos para pasarselos a otra persona, y ahora para que esa persona los pueda instalar exactos a los mios
debo ejecutar el siguiente comando:
- pip install -r requirements.txt

https://pypi.org/project/pipenv/
Quiz entorno virtual

***Clase 7 Listas y diccionarios anidados***

cuando creo el archivo .gitignore y no quiero subir un entorno virtual lo coloco en el .gitignore asÃ­:
- venv/
o asÃ­:
*venv

***Clase 8 List comprehensions***

ejemplo de una list comprehensions

    squares = [i**2 for i in range(1,11) if i % 3!=0]
    print(squares)
voy a leer la list comprehensions anterior:
    - para cada i en el rango que va de 1 hasta 11 voy a guardar esa i elevada al cuadrado solamente si la i modulo 3 es distinta de 0 
        - en otras palabras: para cada i de los nÃºmeros del 1 a 11 voy a guardar esa i al cuadrado solamente si no es divisible por 3
explicaciÃ³n por partes de la list comprehensions
[element for element in iterable if condition]

- element
    - Representa a cada uno de los elementos a poner en una nueva lista
- for element in iterable
    - Ciclo a partir del cual se extraerÃ¡n elementos de otra lista o cualquier iterable
- if condition
    - CondiciÃ³n opcional para filtrar los elementos del ciclo
y se lee asÃ­:
para cada elemento en el iterable voy a guardar ese elemento solo si se cumple la condiciÃ³n

***Clase 9 Dictionary comprehensions***

{key:value for value in iterable if condition}

- key:value -> Representa a cada una de las llaves y valores a poner en el nuevo diccionario
- for value in iterable ->
- if condition -> condiciÃ³n opcional para filtrar los elementos del ciclo
se lee asÃ­:
para cada elemento en el iterable voy a colocar una llave y un valor solamente si se cumple la condiciÃ³n
Quiz alternativa a los ciclos: comprehensions

***Clase 10 Funciones anÃ³nimas: lambda***

las funciones anÃ³nimas valga la redundancia es una funciÃ³n sin nombre, es decir, que no tienen identificador 
y su estructura es asÃ­:

lambda argumentos: expresiÃ³n

las funciones lambda puede tener los argumentos que nosotros queramos o necesitemos pero una sola lÃ­nea de cÃ³digo

se conforma de un argumento que es el parametro que recibe la funciÃ³n para trabajar acompaÃ±ado de la palabra clave lambda, luego tenemos una expresiÃ³n que es una lÃ­nea de cÃ³digo
y tenemos una variable que es un identificador, tener en cuenta que ese identificador no es de la funciÃ³n, es de una variable que va contener un objeto de tipo funciÃ³n que retorna 
todo, recordar que la funciÃ³n lambda no tiene nombre, pero el nombre que tiene esa funciÃ³n con el que la vamos a llamar va ser el nombre de la variable 

- lo bueno de las funciones lambda es que no se necesita poner return
ejemplo:

palindrome = lambda string:string ==sting[::-1]
print(palindrome('oso'))

y en una funciÃ³n normal, serÃ­a asÃ­:

def palindrome(string):
    return string == string[::-1]
print(palindrome('ana'))

lo que es lo mismo y debe retornar True o False, en lugar de usar def uso lambda en lugar de pasar los parametros en parentesis, en lambda los coloco sin parentesis
el identificador se acostumbra a ponerlo como el nombre de la variable en lugar del nombre de la funciÃ³n y en lambda no coloco la palabra clave return, simplemente la omito

***Clase 11 High order functions: filter, map y reduce***

funciÃ³n que recibe otra funciÃ³n como parÃ¡metro
my_list = [1,4,5,6,9,13,19,21]
odd = [i for i in my_list if i %2 != 0]
print(odd)
- filter:
    
Para trabajar con reduce, se tiene que importar la funciÃ³n de la siguiente manera
from functools import reduce
Funciones de orden superior:
    - Es una funciÃ³n que recibe otra funciÃ³n como parÃ¡metro

    - filter: 
        para su uso como ejemplo, tenemos una lista con nÃºmeros:
        my_list = [1,4,5,6,9,13,19,21]
        y quiero tener una lista de esos nÃºmeros, pero Ãºnicamente los que son impares
        [1,5,9,13,19,21]
        y lo usamos solo con list comprehensions
        my_list = [1,4,5,6,9,13,19,21]
        odd = [i for i in my_list if i %2 !=0]
        print(odd)
        
        ahora lo hacemos con list comprehensions y lambda, y la explicaciÃ³n es asÃ­:
        esta lambda lo que hace es, recibe como parÃ¡metro una x y retorna el resultado de una expresiÃ³n x%2 != 0
        en otras palabras, recibe un nÃºmero y retorna True o False si ese nÃºmero es par o impar, ademÃ¡s tenemos una lista que es el segundo
        parÃ¡metro de la funciÃ³n filter, la funciÃ³n filter es una funciÃ³n de orden superior que recibe dos parÃ¡metros una funciÃ³n que en este caso
        es una funciÃ³n anÃ³nima una lambda function y un iterable que en este caso es una lista, ahora estÃ¡ funciÃ³n filter no nos va a devolver
        la lista que nosotros queremos porque retorna un iterador, entonces para que sea una lista lo que hacemos es colocar el mÃ©todo lista por encima 
        de la funciÃ³n filter asÃ­: list(filter)) para que mi resultado quede dentro de una lista

        my_list = [1,4,5,6,9,13,19,21]
        odd = list(filter(lambda x: x%2 != 0, my_list))
        print(odd)

    - map: 
        con list comprehensions
        my_list =[1,2,3,4,5]
        squares = [i**2 for i in my_list]
        print(squares)
        con lambda function y map

        la explicaciÃ³n es asÃ­:
            esta lambda lo que hace es, recibe como parÃ¡metro una x y retorna el resultado de una expresiÃ³n x**2
            en otras palabras, recibe un nÃºmero y retorna ese nÃºmero de la lista elevado a la 2, ademÃ¡s tenemos una lista que es el segundo
            parÃ¡metro de la funciÃ³n map, la funciÃ³n map es una funciÃ³n de orden superior que recibe dos parÃ¡metros, una funciÃ³n que en este caso
            es una funciÃ³n anÃ³nima llamada lambda function y un iterable que en este caso es una lista llamda my_list, ahora esta funciÃ³n map no nos va a devolver
            la lista que nosotros queremos porque retorna un iterador, entonces para que sea una lista lo que hacemos es colocar el mÃ©todo lista por encima 
            de la funciÃ³n map asÃ­: list(map)) para que mi resultado quede dentro de una lista

        funciona exactamente igual a filter, ejemplo:
        my_list = [1,4,5,6,9,13,19,21] 
        odd = list(map(lambda x: x**2, my_list))
        print(odd)
    - reduce: 

        iniciando que importar la funciÃ³n reduce de python 

***Clase 12 Proyecto: filtrando datos***

all_python_devs = [worker["name"] for worker in DATA if worker["language"]=="python"]
donde worker es el nombre de cada una de las partes del cÃ³digo, en lugar de worker se le puede colocar otra designaciÃ³n o nombre
 
Quiz conceptos avanzados de funciones

***Clase 13 Los errores en el cÃ³digo***

Un error en el cÃ³digo es algo normal, todos los ingenieros de programaciÃ³n por ahÃ­ le sale un error, y cuando nos equivocamos python nos avisa que eso pasÃ³
- Errores:
    - SyntaxError:
        - KeyBoardInterrupt:
            - Este pasa cuando de manera forzada detengo la mÃ¡quina con ctrl + c
        - KeyError:
            - Este error pasa cuando en un diccionario no existe la llave a la cual queremos entrar
        - IndexError:
            - Este error pasa cuando en una lista tengo datos y quiero acceder al Ã­ndice o a la posiciÃ³n de esa lista, por eso me arroja este error
        - FileNotFoundError:
            - Este error pasa cuando se quiere abrir un archivo y ese archivo no existe
        - ZeroDivisionError:
            - Este error pasa cuando estamos intentando dividir un nÃºmero entre cero, operaciÃ³n que en matemÃ¡ticas no estÃ¡ permitida
        - ImportError:
            - Este error pasa cuando queremos importar un mÃ³dulo de python
    - Exception:
        Las excepciones detienen el programa y no ejecutan si quiera la primera lÃ­nea del programa

Los traceback de python se leen de abajo hacia arriba, 

***Clase 14 Debugging***
Estudiar debugging de python con visual studio code

***Clase 15 Manejo de excepciones***
En esta clase se va a probar que le estamos pidiendo al usuario que nos ingrese una palabra y lo que nos ingresa es un nÃºmero, entonces para ello
y evitar que nuestro programa se reviente le vamos a manejar una excepciÃ³n 

- Si le pasamos una cadena vacÃ­a python lo toma como verdadero, es decir, como si fuÃ©se un palindromo, sin embargo, no deberÃ­a hacer eso, entonces lo que se hace
es capturar tambiÃ©n ese error, hacer una funciÃ³n para eso.

- try: finally:
    - Se usa usualmente al final de una estructura try, except, y se puede cerrar un archivo, liberar recursos externos, entre otros.
    - Es muy raro su uso
***Clase 16 Poniendo a prueba el manejo de excepciones***

***Clase 17 Assert statements***
.isnumeric() -> lo que hace es devolver verdadero si ese string corresponde a una especie de nÃºmero
y si por el contrario es ingresa una letra se activa el mensaje

Quiz manejo de errores

***Clase 18 Â¿CÃ³mo trabajar con archivos?***

***Clase 19 Trabajando con archivos de texto en Python***
Quiz manejo de archivos

***Clase 20 Reto final: Juego del Ahorcado o Hangman Game***

***Clase 21 ContinÃºa tu camino profesional con Python***
