***Clase 2 Zen de python***

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.
- Special cases aren't special enough to break the rules.
- Although practicality beats purity.
- Errors should never pass silently.
- Unless explicitly silenced.
- In the face of ambiguity, refuse the temptation to guess.
- There should be one-- and preferably only one --obvious way to do it.
- Although that way may not be obvious at first unless you're Dutch.
- Now is better than never.
- Although never is often better than *right* now.
- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.
- Namespaces are one honking great idea -- let's do more of those!

Traducci√≥n

- Bello es mejor que feo:
    - Pyhton es est√©ticamente superior a cualquier otro lenguaje de programaci√≥n. Al momento de escribir c√≥digo, es mejor que sea de manera limpia y est√©tica.
- Expl√≠cito es mejor que impl√≠cito:
    - Hacer m√°s f√°cil que las otras personas entiendan el c√≥digo.
- Simple es mejor que complejo:
    - Es mejor tener una implementaci√≥n simple, que ocupe pocas lineas de c√≥digo y sea entendible, a que sea una larga y complicada.
- Complejo es mejor que complicado:
    - Si tenemos que extendernos en la implementaci√≥n y hacerla m√°s compleja para que el c√≥digo si se entienda, esto es mejor que hacerlo simple y mal.
- Plano es mejor que anidado:
    - El anidamiento es cuando tenemos un bloque de c√≥digo dentro de otro bloque de c√≥digo (dependiendo de este). Esto se nota en Python por la identaci√≥n, nos quedar√≠an estos bloques muy corridos a la derecha.
    - Es mejor evitar el anidamiento, y hacer las cosas de manera plana.
- Espaciado es mejor que denso:
    - Por la identaci√≥n de Python (sus sangr√≠as), este principio se nos hace imposible de esquivar. El c√≥digo inevitablemente es espaciado.
- La legibilidad es importante:
    - Es importante que otros programadores puedan entender lo que estamos escribiendo. Esto hace m√°s f√°ciles las cosas cuando trabajemos con otros en los proyectos.
- Los casos especiales no son lo suficientemente especiales cpmo para romper las reglas (sin embargo, la practicidad le gana a la pureza):
    - Siempre que podamos respetar estas reglas que nos plantea Python, es mejor as√≠. Sin embargo, si por el hecho de hacer un c√≥digo muy puro o muy ‚ÄòPythonista‚Äô, este pierde legibilidad, es mejor ser m√°s pr√°cticos y romper o saltearnos algunas de estas reglas para que el c√≥digo sea m√°s eficiente. Por lo tanto, llegado el momento debermos decidir si es mejor hacer las cosas de manera pura o pr√°ctica.
- Los errores nunca deber√≠an pasar silenciosamente (a menos que se silencien expl√≠citamente):
    - Manejar los erroes es fundamental. Cada error nos dice algo y hay que prestarle atenci√≥n. A menos que seas capaz de silenciar un error expl√≠citamente, aunque para esto hay que tener criterio.
- Frente a la ambiguedad, evitar la tentaci√≥n de adivinar:
    - Nuestro c√≥digo deber√≠a solamente tener una interpretaci√≥n. Si en un contexto significa algo, y en otro otra cosa, es mejor que lo revisemos y busquemos una soluci√≥n.
- Deber√≠a haber una, y preferiblemente sola, una manera obvia de hacerlo. (A pesar de que esa manera no sea obvia a menos que seas holand√©s):
    - Esto hace referencia al creador de Python ''Guido van Rossum", que de manera muy inteligente encontrar las soluciones precisas a los problemas, y deber√≠amos imitarlo.
- Ahora es mejor que nunca:
    - Es mejor desarrollar nuestra soluci√≥n cu√°nto antes, no dejarlo para ma√±ana o para mas adelante.
- A pesar de que nunca es muchas veces mejor que ahora mismo:
    - Si por hacer las cosas ya y tenemos poco tiempo, si es mejor dejarlo para despu√©s y no hacerlo apurado y mal.
- Si la implementaci√≥n es d√≠ficil de explicar, es una mala idea, y si es f√°cil de explicar, es una buena idea:
    - Si somos capaces de explicar nuestra implementaci√≥n a otros desarrolladores paso a paso, es una buena idea. En cambio si no podemos hacerlo, significa que ni nosotros entendemos la implementaci√≥n y deber√≠amos repensar nuestra forma de encarar la soluci√≥n.
- **Los espacios de nombres son una gran idea, ¬°Tengamos m√°s de esos! (namespaces):
    - Es el nombre que se ha indicado luego de la palabra import, es decir la ruta (namespace) del m√≥dulo. (Lo veremos a profundidad m√°s adelante).

***Clase 3 ¬øQu√© es la documentaci√≥n?***

En esta encontramos todo con respecto a la funcionalidad del lenguaje, errores, sint√°xis, referencias del lenguajes, tutoriales
ah√≠ encontramos los PEP: son los documentos que conforman a toda la gu√≠a de estilos del lenguaje, es una gu√≠a de como se debe escribir el lenguaje python, el pep8 es la guia de estilos de python
en esta podemos ver las buenas pr√°cticas que debemos tener para escribir python

https://peps.python.org/pep-0008/

***Clase 4 ¬øQu√© es un entorno virtual?***

M√≥dulo: B√°sicamente es c√≥digo escrito por otra persona que nos sirve para solucionar un problema de manera r√°pida
por ejemplo tenemos el m√≥dulo Random

Es ese python aislado para un solo proyecto que tiene sus propios m√≥dulos y funcionar √∫nicamente ah√≠

Aprend√≠ sobre los entornos virtuales gracias al Curso de Creaci√≥n Lenguajes de Programaci√≥n: Int√©rpretes, la idea es sencilla, de hecho el concepto es similar al de los contenedores de Docker, como profesional empezar√°s a requerir de trabajar diversos proyectos que trabajen con diferentes versiones, ya sea del lenguaje o de alg√∫n m√≥dulo.
Ser√≠a una cat√°strofe tener que instalar y actualizar m√≥dulos para cada proyecto cuidando que ninguno se rompa, porque f√°cilmente podr√≠as actualizar un m√≥dulo que, para un proyecto funcione, pero para otro deje de funcionar, es por eso que se crea el concepto de entornos virtuales.
Este concepto lo tienen muchos lenguajes, y lo genial es que soluciona muy bien el problema de la compatibilidad entre proyectos, porque cada entorno virtual es independiente y funciona con las versiones que se les hayan instalado ah√≠ mismo üòÑ.

Recomendado de la Clase:

https://platzi.com/cursos/interpretes-software/

***Clase 5 El primer paso profesional: creaci√≥n de un entorno virtual***

para crear un ambiente en windows con cmder me funcion√≥ as√≠:
- python -m venv venv
- python -m venv venv2

- -m -> significa que vamos a modificar el funcionamiento normal por otra cosa, y en python -m significa modulo, es decir, vamos a llamar a un m√≥dulo interno del lenguaje
- venv -> significa que estamos llamando al m√≥dulo venv que hace referencia al entorno virtual, lo que quiere decir es que le estamos diciendo a la consola que nos cree un virtual environment
- venv2 -> es el nombre que le vamos a colocar al entorno virtual

y ya con eso se nos crea el entorno virtual para trabajar 
- ahora para entrar al entorno virtual y trabajar, es decir, activarlo es as√≠:

- para activar el entorno virtual en Mac o linux:
    - source venv/bin/activate
        donde venv recordar que es el nombre del entorno virtual
- para activar el entorno virtual en windows con cmder
    .\venv\Scripts\activate
- para activar el entorno virtual en windows con git bash
    source venv2/Scripts/activate

usualmente en el mundo de la programaci√≥n se suele llamar al entorno virtual que se crea como venv al igual que el m√≥dulo, pero en este ejemplo para evitar confusiones lo cre√© como venv2

***Clase 6 Instalaci√≥n de dependencias con pip***

- PIP: Package Installer for Python
hay m√≥dulos que est√°n dentro de python pero hay otros que no est√°n instalados, por ende, para obtenerlos usamos pip
este m√≥dulo viene dentro de python para instalar otros m√≥dulos
por ejemplo:
    - Requests
    - BeautifulSoup4
    - Pandas
    - Numpy
    - Pytest

cuando ingresamos al entorno virtual e instalamos m√≥dulos o dependencias, estas quedan instaladas solo en ese entorno virtual
- pip freeze: con este comando podemos ver qu√© m√≥dulos tenemos instalados ya sea en nuestro entorno virtual como por fuera
y para instalar un m√≥dulo es as√≠, como ejemplo:

- pip install pandas
- pip install django

IMPORTANTE:

si por ejemplo yo estoy desarrollando una app y quiero que un compa√±ero u otra persona en su entorno instale exactamente los mismos requerimientos que yo tengo
o los mismos m√≥dulos, lo hago de la siguiente manera:

- pip freeze > requirements.txt
y ya con eso, tenemos los programas que tengo en mi local listos para pasarselos a otra persona, y ahora para que esa persona los pueda instalar exactos a los mios
debo ejecutar el siguiente comando:
- pip install -r requirements.txt

https://pypi.org/project/pipenv/
Quiz entorno virtual

***Clase 7 Listas y diccionarios anidados***

cuando creo el archivo .gitignore y no quiero subir un entorno virtual lo coloco en el .gitignore as√≠:
- venv/
o as√≠:
*venv

***Clase 8 List comprehensions***

ejemplo de una list comprehensions

    squares = [i**2 for i in range(1,11) if i % 3!=0]
    print(squares)
voy a leer la list comprehensions anterior:
    - para cada i en el rango que va de 1 hasta 11 voy a guardar esa i elevada al cuadrado solamente si la i modulo 3 es distinta de 0 
        - en otras palabras: para cada i de los n√∫meros del 1 a 11 voy a guardar esa i al cuadrado solamente si no es divisible por 3
explicaci√≥n por partes de la list comprehensions
[element for element in iterable if condition]

- element
    - Representa a cada uno de los elementos a poner en una nueva lista
- for element in iterable
    - Ciclo a partir del cual se extraer√°n elementos de otra lista o cualquier iterable
- if condition
    - Condici√≥n opcional para filtrar los elementos del ciclo
y se lee as√≠:
para cada elemento en el iterable voy a guardar ese elemento solo si se cumple la condici√≥n

***Clase 9 Dictionary comprehensions***

{key:value for value in iterable if condition}

- key:value -> Representa a cada una de las llaves y valores a poner en el nuevo diccionario
- for value in iterable ->
- if condition -> condici√≥n opcional para filtrar los elementos del ciclo
se lee as√≠:
para cada elemento en el iterable voy a colocar una llave y un valor solamente si se cumple la condici√≥n
Quiz alternativa a los ciclos: comprehensions

***Clase 10 Funciones an√≥nimas: lambda***

las funciones an√≥nimas valga la redundancia es una funci√≥n sin nombre, es decir, que no tienen identificador 
y su estructura es as√≠:

lambda argumentos: expresi√≥n

las funciones lambda puede tener los argumentos que nosotros queramos o necesitemos pero una sola l√≠nea de c√≥digo

se conforma de un argumento que es el parametro que recibe la funci√≥n para trabajar acompa√±ado de la palabra clave lambda, luego tenemos una expresi√≥n que es una l√≠nea de c√≥digo
y tenemos una variable que es un identificador, tener en cuenta que ese identificador no es de la funci√≥n, es de una variable que va contener un objeto de tipo funci√≥n que retorna 
todo, recordar que la funci√≥n lambda no tiene nombre, pero el nombre que tiene esa funci√≥n con el que la vamos a llamar va ser el nombre de la variable 

- lo bueno de las funciones lambda es que no se necesita poner return
ejemplo:

palindrome = lambda string:string ==sting[::-1]
print(palindrome('oso'))

y en una funci√≥n normal, ser√≠a as√≠:

def palindrome(string):
    return string == string[::-1]
print(palindrome('ana'))

lo que es lo mismo y debe retornar True o False, en lugar de usar def uso lambda en lugar de pasar los parametros en parentesis, en lambda los coloco sin parentesis
el identificador se acostumbra a ponerlo como el nombre de la variable en lugar del nombre de la funci√≥n y en lambda no coloco la palabra clave return, simplemente la omito

***Clase 11 High order functions: filter, map y reduce***

funci√≥n que recibe otra funci√≥n como par√°metro
my_list = [1,4,5,6,9,13,19,21]
odd = [i for i in my_list if i %2 != 0]
print(odd)
- filter:
    
Para trabajar con reduce, se tiene que importar la funci√≥n de la siguiente manera
from functools import reduce
Funciones de orden superior:
    - Es una funci√≥n que recibe otra funci√≥n como par√°metro

    - filter: 
        para su uso como ejemplo, tenemos una lista con n√∫meros:
        my_list = [1,4,5,6,9,13,19,21]
        y quiero tener una lista de esos n√∫meros, pero √∫nicamente los que son impares
        [1,5,9,13,19,21]
        y lo usamos solo con list comprehensions
        my_list = [1,4,5,6,9,13,19,21]
        odd = [i for i in my_list if i %2 !=0]
        print(odd)
        
        ahora lo hacemos con list comprehensions y lambda, y la explicaci√≥n es as√≠:
        esta lambda lo que hace es, recibe como par√°metro una x y retorna el resultado de una expresi√≥n x%2 != 0
        en otras palabras, recibe un n√∫mero y retorna True o False si ese n√∫mero es par o impar, adem√°s tenemos una lista que es el segundo
        par√°metro de la funci√≥n filter, la funci√≥n filter es una funci√≥n de orden superior que recibe dos par√°metros una funci√≥n que en este caso
        es una funci√≥n an√≥nima una lambda function y un iterable que en este caso es una lista, ahora est√° funci√≥n filter no nos va a devolver
        la lista que nosotros queremos porque retorna un iterador, entonces para que sea una lista lo que hacemos es colocar el m√©todo lista por encima 
        de la funci√≥n filter as√≠: list(filter)) para que mi resultado quede dentro de una lista

        my_list = [1,4,5,6,9,13,19,21]
        odd = list(filter(lambda x: x%2 != 0, my_list))
        print(odd)

    - map: 
        con list comprehensions
        my_list =[1,2,3,4,5]
        squares = [i**2 for i in my_list]
        print(squares)
        con lambda function y map

        la explicaci√≥n es as√≠:
            esta lambda lo que hace es, recibe como par√°metro una x y retorna el resultado de una expresi√≥n x**2
            en otras palabras, recibe un n√∫mero y retorna ese n√∫mero de la lista elevado a la 2, adem√°s tenemos una lista que es el segundo
            par√°metro de la funci√≥n map, la funci√≥n map es una funci√≥n de orden superior que recibe dos par√°metros, una funci√≥n que en este caso
            es una funci√≥n an√≥nima llamada lambda function y un iterable que en este caso es una lista llamda my_list, ahora esta funci√≥n map no nos va a devolver
            la lista que nosotros queremos porque retorna un iterador, entonces para que sea una lista lo que hacemos es colocar el m√©todo lista por encima 
            de la funci√≥n map as√≠: list(map)) para que mi resultado quede dentro de una lista

        funciona exactamente igual a filter, ejemplo:
        my_list = [1,4,5,6,9,13,19,21] 
        odd = list(map(lambda x: x**2, my_list))
        print(odd)
    - reduce: 

        iniciando que importar la funci√≥n reduce de python 

***Clase 12 Proyecto: filtrando datos***

all_python_devs = [worker["name"] for worker in DATA if worker["language"]=="python"]
donde worker es el nombre de cada una de las partes del c√≥digo, en lugar de worker se le puede colocar otra designaci√≥n o nombre
 
Quiz conceptos avanzados de funciones

***Clase 13 Los errores en el c√≥digo***

Un error en el c√≥digo es algo normal, todos los ingenieros de programaci√≥n por ah√≠ le sale un error, y cuando nos equivocamos python nos avisa que eso pas√≥
- Errores:
    - SyntaxError:
        - KeyBoardInterrupt:
            - Este pasa cuando de manera forzada detengo la m√°quina con ctrl + c
        - KeyError:
            - Este error pasa cuando en un diccionario no existe la llave a la cual queremos entrar
        - IndexError:
            - Este error pasa cuando en una lista tengo datos y quiero acceder al √≠ndice o a la posici√≥n de esa lista, por eso me arroja este error
        - FileNotFoundError:
            - Este error pasa cuando se quiere abrir un archivo y ese archivo no existe
        - ZeroDivisionError:
            - Este error pasa cuando estamos intentando dividir un n√∫mero entre cero, operaci√≥n que en matem√°ticas no est√° permitida
        - ImportError:
            - Este error pasa cuando queremos importar un m√≥dulo de python
    - Exception:
        Las excepciones detienen el programa y no ejecutan si quiera la primera l√≠nea del programa

Los traceback de python se leen de abajo hacia arriba, 

***Clase 14 Debugging***
Estudiar debugging de python con visual studio code

***Clase 15 Manejo de excepciones***
En esta clase se va a probar que le estamos pidiendo al usuario que nos ingrese una palabra y lo que nos ingresa es un n√∫mero, entonces para ello
y evitar que nuestro programa se reviente le vamos a manejar una excepci√≥n 

- Si le pasamos una cadena vac√≠a python lo toma como verdadero, es decir, como si fu√©se un palindromo, sin embargo, no deber√≠a hacer eso, entonces lo que se hace
es capturar tambi√©n ese error, hacer una funci√≥n para eso.

- try: finally:
    - Se usa usualmente al final de una estructura try, except, y se puede cerrar un archivo, liberar recursos externos, entre otros.
    - Es muy raro su uso
***Clase 16 Poniendo a prueba el manejo de excepciones***

***Clase 17 Assert statements***
.isnumeric() -> lo que hace es devolver verdadero si ese string corresponde a una especie de n√∫mero
y si por el contrario es ingresa una letra se activa el mensaje

Quiz manejo de errores

***Clase 18 ¬øC√≥mo trabajar con archivos?***
Archivos de texto:
    - .txt
    - .py
    - .json
    - .js
    - .xml

Para abrir un archivo de texto con python tenemos 3 formas de hacerlo
    - R -> Lectura
    - W -> Escritura(sobrescribir)
        - Lo que se hace es que si por ejemplo, tengo ya unos scripts en un archivo y uso ese modo de apertura lo que estoy haciendo ah√≠ es 
        reemplazando lo que hay ya ah√≠ en ese archivo, es decir quitando lo que estaba y queda lo √∫ltimo que coloqu√©
    - A -> Escritura(agregar al final)
        - Lo que se hace con este es por ejemplo si ya tengo unos datos o scripts en ese archivo lo nuevo que coloco se agrega a lo √∫ltimo del archivo, no se borra
        como el modo anterior
para abrir un archivo es as√≠:
funci√≥n interna de python -> open        
with open ("./ruta/del/archivo.txt", "r") as f:


***Clase 19 Trabajando con archivos de texto en Python***

- funci√≥n de READ -> LEER
    - Para esta funci√≥n usamos la denominaci√≥n r para dar a entender que no m√°s queremos leer el archivo que le estamos pasando

- funci√≥n write -> escribir
    con esta funci√≥n lo que hacemos es crear un archivo en la carpeta numbers con el nombre de names.txt y usamos el metodo w
    en ese documento colocamos los nombres que est√°n en la lista names, y si por ejemplo al momento de escribir un nombre lo escrib√≠ mal
    y quiero escribirlo como es realmente lo que hago es corregir y el programa me sobre escribe ese dato, valga la redundancia lo actualiza

- funci√≥n append -> agregar
    - con esta funci√≥n si por ejemplo tenemos ya un archivo en este caso el archivos names.txt y lo que queremos es agregarle informaci√≥n sin que
    el archivo original sobre escriba lo que ya est√° entonces usamos la denominaci√≥n "a" que significa append(agregar)
Quiz manejo de archivos

***Clase 20 Reto final: Juego del Ahorcado o Hangman Game***

- Incorporar list comprehensions
- Investigar la funci√≥n enumerate
- El metodo get de los diccionarios
- cls, es para limpiar la pantalla en windows

***Clase 21 Contin√∫a tu camino profesional con Python***
